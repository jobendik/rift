<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Integration Debug</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            padding: 20px;
            margin: 0;
        }
        .debug-section {
            border: 1px solid #0f0;
            margin: 10px 0;
            padding: 10px;
            background: #001100;
        }
        .debug-title {
            color: #ff0;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .error { color: #f00; }
        .success { color: #0f0; }
        .warning { color: #fa0; }
        .info { color: #0af; }
        pre {
            background: #111;
            padding: 10px;
            border-left: 3px solid #0f0;
            overflow-x: auto;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #fa0;
        }
    </style>
</head>
<body>
    <h1>üîç RIFT UI Integration Debug Tool</h1>
    <p>This will diagnose EXACTLY what's happening with the UI integration.</p>
    
    <button onclick="runFullDiagnostic()">üöÄ RUN FULL DIAGNOSTIC</button>
    <button onclick="clearResults()">üßπ CLEAR RESULTS</button>
    <button onclick="forceCreateAmmoDisplay()">üíâ FORCE CREATE AMMO DISPLAY</button>
    
    <div id="results"></div>

    <script>
        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = message;
            results.appendChild(div);
            console.log(message);
        }

        function section(title) {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = 'debug-section';
            div.innerHTML = `<div class="debug-title">${title}</div>`;
            results.appendChild(div);
            return div;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        async function runFullDiagnostic() {
            clearResults();
            log('üîç Starting comprehensive UI integration diagnostic...', 'info');
            
            // 1. Check Basic Environment
            const envSection = section('üåç ENVIRONMENT CHECK');
            try {
                log('‚úì Window object exists', 'success');
                log(`‚úì Location: ${window.location.href}`, 'info');
                log(`‚úì User Agent: ${navigator.userAgent}`, 'info');
            } catch (e) {
                log(`‚ùå Environment error: ${e.message}`, 'error');
            }

            // 2. Check Global Objects
            const globalSection = section('üåê GLOBAL OBJECTS');
            const globals = ['world', 'scene', 'camera', 'player', 'EventManager'];
            globals.forEach(global => {
                if (window[global]) {
                    log(`‚úì window.${global} exists`, 'success');
                    if (global === 'world' && window.world.player) {
                        log(`‚úì world.player exists`, 'success');
                        if (window.world.player.weaponSystem) {
                            log(`‚úì world.player.weaponSystem exists`, 'success');
                            if (window.world.player.weaponSystem.currentWeapon) {
                                const weapon = window.world.player.weaponSystem.currentWeapon;
                                log(`‚úì Current weapon: ${weapon.type || 'unknown'}`, 'success');
                                log(`‚úì Ammo: ${weapon.roundsLeft}/${weapon.roundsPerClip}`, 'success');
                            } else {
                                log(`‚ö†Ô∏è world.player.weaponSystem.currentWeapon is null`, 'warning');
                            }
                        } else {
                            log(`‚ùå world.player.weaponSystem missing`, 'error');
                        }
                    }
                } else {
                    log(`‚ùå window.${global} missing`, 'error');
                }
            });

            // 3. Check EventManager
            const eventSection = section('üì° EVENT MANAGER');
            if (window.EventManager) {
                log('‚úì EventManager exists', 'success');
                
                // Test event system
                let testEventReceived = false;
                const testHandler = () => { testEventReceived = true; };
                
                try {
                    window.EventManager.subscribe('debug:test', testHandler);
                    window.EventManager.emit('debug:test', { test: true });
                    
                    setTimeout(() => {
                        if (testEventReceived) {
                            log('‚úì EventManager working correctly', 'success');
                        } else {
                            log('‚ùå EventManager not working', 'error');
                        }
                        window.EventManager.unsubscribe('debug:test', testHandler);
                    }, 100);
                } catch (e) {
                    log(`‚ùå EventManager error: ${e.message}`, 'error');
                }
            } else {
                log('‚ùå EventManager missing', 'error');
            }

            // 4. Check UI Components
            const uiSection = section('üñºÔ∏è UI COMPONENTS');
            try {
                // Check for UI elements in DOM
                const hudElements = document.querySelectorAll('[class*="rift-"]');
                log(`Found ${hudElements.length} RIFT UI elements in DOM`, hudElements.length > 0 ? 'success' : 'warning');
                
                hudElements.forEach((el, i) => {
                    log(`  ${i+1}. ${el.className} (${el.tagName})`, 'info');
                });

                // Check for ammo display specifically
                const ammoDisplay = document.querySelector('.rift-ammo, #ammo-display');
                if (ammoDisplay) {
                    log('‚úì Ammo display element found in DOM', 'success');
                    log(`  Content: "${ammoDisplay.textContent}"`, 'info');
                    log(`  Classes: ${ammoDisplay.className}`, 'info');
                } else {
                    log('‚ùå Ammo display element NOT found in DOM', 'error');
                }

            } catch (e) {
                log(`‚ùå UI check error: ${e.message}`, 'error');
            }

            // 5. Check Module Loading
            const moduleSection = section('üì¶ MODULE LOADING');
            try {
                // Try to import the AmmoDisplay class
                const ammoModule = await import('./src/components/ui/hud/AmmoDisplay.js');
                if (ammoModule.AmmoDisplay) {
                    log('‚úì AmmoDisplay class loaded successfully', 'success');
                } else {
                    log('‚ùå AmmoDisplay class not exported', 'error');
                }
            } catch (e) {
                log(`‚ùå AmmoDisplay import error: ${e.message}`, 'error');
            }

            // 6. Check UIManager
            const uiManagerSection = section('üéõÔ∏è UI MANAGER');
            if (window.world && window.world.uiManager) {
                log('‚úì UIManager exists', 'success');
                const uiManager = window.world.uiManager;
                
                // Check if UIManager has components
                if (uiManager.components) {
                    log(`‚úì UIManager has ${Object.keys(uiManager.components).length} components`, 'success');
                    Object.keys(uiManager.components).forEach(key => {
                        log(`  - ${key}: ${uiManager.components[key].constructor.name}`, 'info');
                    });
                } else {
                    log('‚ùå UIManager.components missing', 'error');
                }

                // Check if UIManager has ammoDisplay
                if (uiManager.ammoDisplay) {
                    log('‚úì UIManager.ammoDisplay exists', 'success');
                } else {
                    log('‚ùå UIManager.ammoDisplay missing', 'error');
                }
            } else {
                log('‚ùå UIManager missing', 'error');
            }

            // 7. Network/Loading Check
            const networkSection = section('üåê NETWORK/LOADING');
            const performanceEntries = performance.getEntriesByType('resource');
            const jsFiles = performanceEntries.filter(entry => entry.name.endsWith('.js'));
            log(`Loaded ${jsFiles.length} JavaScript files`, 'info');
            
            const failedFiles = jsFiles.filter(entry => entry.responseStart === 0);
            if (failedFiles.length > 0) {
                log(`‚ùå ${failedFiles.length} JavaScript files failed to load:`, 'error');
                failedFiles.forEach(file => {
                    log(`  - ${file.name}`, 'error');
                });
            } else {
                log('‚úì All JavaScript files loaded successfully', 'success');
            }

            log('üèÅ Diagnostic complete!', 'info');
        }

        async function forceCreateAmmoDisplay() {
            log('üíâ Attempting to force create AmmoDisplay...', 'info');
            
            try {
                // Import AmmoDisplay
                const ammoModule = await import('./src/components/ui/hud/AmmoDisplay.js');
                const AmmoDisplay = ammoModule.AmmoDisplay;
                
                // Create container
                let container = document.querySelector('#debug-ammo-container');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'debug-ammo-container';
                    container.style.cssText = `
                        position: fixed;
                        top: 50px;
                        right: 50px;
                        z-index: 10000;
                        background: rgba(0,255,0,0.1);
                        border: 2px solid #0f0;
                        padding: 20px;
                        color: #0f0;
                        font-family: monospace;
                    `;
                    document.body.appendChild(container);
                }

                // Create AmmoDisplay instance
                const ammoDisplay = new AmmoDisplay({
                    container: container,
                    id: 'debug-ammo-display'
                });

                log('‚úì AmmoDisplay created successfully!', 'success');
                log('‚úì Check top-right corner of the screen', 'info');

                // Try to trigger player ready if available
                if (window.world && window.world.player) {
                    setTimeout(() => {
                        log('üíâ Triggering player ready event...', 'info');
                        ammoDisplay._onPlayerReady({ player: window.world.player });
                    }, 1000);
                }

            } catch (e) {
                log(`‚ùå Force create failed: ${e.message}`, 'error');
                log(`Stack: ${e.stack}`, 'error');
            }
        }

        // Auto-run diagnostic when page loads
        window.addEventListener('load', () => {
            setTimeout(runFullDiagnostic, 1000);
        });
    </script>
</body>
</html>
